-------------------------------------------------------------------------------------

Стр. 27

Глава 3: Конфигурация

Что ж, сейчас вы знаете как мы будем использовать Git и вам комфортно в командной
строке. Сейчас мы фактически начнём использовать Git. Конечно, мы начнём с его
установки!

-------------------------------------------------------------------------------------

Стр. 28

[ Установка Git ]

Установка Git очень сильно зависит от используемой ОС, такчто я сначала покажу как
это сделать сначала в Mac, затем в Windows.

[ MacOS ]

Существует несколько способов установки Git в Mac: самый простой способ это 
использовать Git OS X Installer. Зайдите на git-osx-installer page в Google Code и 
кликните "Загрузить пакет". Затем загрузите свежий образ, в моём случае это Git 1.7.1.
Смонтируйте образ у установите содержащиеся внутри образа пакеты. Если вы планируете
использовать Git с помощью программ, отличных от терминала, запустите Shell скрипт
в образе.
Если вы поьзуетесь менеджнром пакетов, таким как Homebrew или MacPorts, то это
наипростейший способ установки Git.

-------------------------------------------------------------------------------------

Стр. 29

(Homebrew)

\$ sudo brew install git

(MacPorts)

\$ sudo port selfupdate
\$ sudo port install git-core

(Часть с sudo просто значит запуск команды от пользователя root. Вы обычно будете это
делаеть, когда устанавливаете ПО. Когда используете sudo, командная строка запросит
пароль вашего аккаунта.)
Если вы хотите действительно сложный способ, вы можете установить Git из исходных
кодов. НО сначала вам при дётся установить Apple Developer Tools. Вы можете получить
их ан http://developer.apple.com/mac/. Они находятся на правой боковой панели (Если
у вас не Snow Lopard, установите их с CD/DVD для вашей версии Mac OS X). Как только
всё сделаете, можете продолжать.
Мы собираемся устанавливать Git в директорию /user/local, таким образом убедитесь, 
что терминал сможет его найти в переменной \$PATH. Используя команды о которых 
мы говорили выше, проверьте в ней путь /usr/local/bin (bin означает двоичный и это 
поддиректория, в которой сохранён откомпилированный Git). Если пути нет, то
откройте файл .profile и добавьте такую строчку в конец
export PATH=”/usr/local/bin:\$PATH”

-------------------------------------------------------------------------------------

Стр. 30

        Подсказка от Rock*
        Что такое .profile? Терминал Mac испоьзует файл под названием .profile для 
        хранения списка настроек командной строки. Как только вы сильнее привыкните
        к командной строке, вы заметите, что обращаетесь к этому и другим файлам для
        редактирования. Файл /.profile находится в вашей домашней директории, но вы 
        не сожете увидеть его по умолчанию. Самый простой способ получить к нему 
        доступ через терминал с помощью команды mate ~/.profile. Замените слово mate 
        на выбранный вами редактор.
После того, как вы сохранили и закрыли файл .profile, перезапустите терминал.
Выполнение echo \$PATH покажет вам, что директория /usr/local/bin теперь в перменной
окружения \$PATH.
Сейчас мы готовы к установке Git. Мы выполним несколько команд, которые мы не обсуждали, 
так что если вас не устраивает такое положение, то вам, вероятно, следует использовать
один из предыдущих вариантов. Если вы решились, просто будьте осторожны и пусть эти 
команды служат отправной точкой в ваших исследованиях командной строки!
Мы начнём  с загрузки и распаковывания исходного кода Git:
\$ curl -O http://kernel.org/pub/software/scm/git/git-1.7.1.tar.bz2
\$ tar xzvf git-1.7.1
Сейчас мы перейдём в эту папку и соберём Git:
\$ cd git-1.7.1
\$ ./configure --prefix=/usr/local
\$ make
\$ make install
Готово! Сейчас вы можете удалить папку и архив:
\$ cd ..
\$ rm git-1.7.1
\$ rm git-1.7.1.tar.bz2

-------------------------------------------------------------------------------------

Стр.31

Теперь вы готовы к работе. Вы сможете убедиться, что Git успешно установился 
выполнением команды:
\$ which git
Вы получите /usr/local/bin/git. Если это так, то вы удачно установили Git из исходного 
кода! (Спасибо Дэну Бенжамину за эту инструкцию по устанвке Git из исходных кодов).

[ Windows ]

В связи с корнями от Linux, Git не работает как "родной" в Windows, как и на Mac. Тем 
не менее, пользователи ПК могут воспользоваться преимуществами Git. Вот как это 
делается.
Мы установим Git на Windows, используя установщик Msysygit, который вы сможете загрузить
на странице проекта в Google Code. Загрузите последнюю версию со страницы загрузки, 
которая, кажется, под номером 1.7.0.2 на момент написания статьи (помечена как бета-
-версия). Запустите установщик и следуйте указаниям. Это будет похоже на обычный процесс
установки приложения до тех пока вы не прийдёте к этому окну:
{рисунок}

-------------------------------------------------------------------------------------

Стр. 32

Оно спрашивает как вы хотите интегрировать Git в вашу систему. Если вы пробежитесь по 
опциям, то увидите, что по умолчанию Msysgit создаст отдельную командную строку из 
которой вы можете выполнять команды Git. Конечно, вы сможете выполнять все обычные
команды тоже. Вторя опция включит путь до утилит Git в переменную окружения PATH, 
позволяя вам выполнять команды Git из обычной cmd.exe. Последняя опция, дополненная
предупреждением, включит утилиты Git и Unix в переменную PATH. Это перезапишет утилиты
командной строки Windows, которые имеют те же имена, что и в Unix, так что убедитесь,
что вы этого хотите при выборе этой опции. Так как я предпочёл утилиты Unix, то я
выбрал третью опцию. Если вы не уверены, то вторая  опуця более подходящая, чем первая.
Следующее диалоговое окно может внести некоторую путаницу:
(рисунок)
Здесь говорится о невидимых символах, которые помечают окончания строк. Unix системы
требуют символ первода строки, в то время как Windows системы требуют символа возврата
каретки и первода строки.
Согласно диалоговому окну, опция "Извлекать в стиле Windows, фиксировать в стиле Unix"
лучший вариант для Windows, когда реализуются кросс-платформенные проекты. Если 

-------------------------------------------------------------------------------------

Стр. 33

вы работаете только на Windows машинах, можете выбрать опцию "Извлекать как есть, 
фиксировать как есть", но я не рекомендую этот способ. Вы никогда не знаете когда 
ваш проект понадобится отредактировать на другой ОС.
После этих решений установка Git завершена. Вы вероятно получите ярлых "Git Bash" на
вашем рабочем столе. Хотя, возможно, вы решили включить Git в переменную PATH, так что
вы можете использовать команды из обычной командной строки. Этот ярлык обеспечивает
несколько дополнительных функций, таких как подсветка текста и немного информации по Git
в командной строке. Как только вы приобретёте навык работы с Git, вы можете выбирать как
угодно.
Итак, сейчас вы установили Git в вашу систему. Время кое-что настроить до того как мы
начнём его использовать.

[ Настройка Git ]

Я знаю, мы движемся медленно, но есть ещё один шаг, который необходимо сделать, прежде
чем мы сможем начать. Мы настроем Git так, чтобы он знал кто вы.
Откройте вашу командную строку (в действительности вы не должны закрывать её до конца 
книги) и выполните это:
\$ git config --global user.name “Andrew Burgess”
\$ git config --global user.email “andrew8088@gmail.com”
Конечно, замените моё имя и e-mail на свои. Эта информация очень важна и вы увидите 
позже почему. Несмотря на то, что есть и другик парамеиры конфигурации которые вы можете
использовать, я сейчас установлю просто ещё один сейчас: все языки программирования 
которые я использую независимы от числа пробелов, поэтому я установлю:
\$ git config --global apply.whitespace nowarn

-------------------------------------------------------------------------------------

Стр. 34

Так Git будет игнорировать изменения пробелов. Существует много других конфигурационных
настроек, но они вам не нужны до более глубокого понимания Git. Если вы хотите о них
узнать, вы можете посмотреть их в официальной документации Git.

[ Использование Git ]

Что ж, сейчас мы окончательно готовы начать использовать Git! Первым шагом служит
создание Git репозитория. Запустите свою командную строку, создайте новую директорию
в выбранном месте, перейдите в неё и давайте начнём.

( Git Init )

Это невероятно просто начать использовать Git в проекте. Просто запустите эту команду
в пределах директории с проектом:
\$ git init
Initialized empty Git repository in /Users/andrew/
Documents/Projects/newApp/.git/
Это всё, это всё, что вам нужно сделать. Будь то вы только начинаете свой проект или 
вы уже работали над ним некоторое время, просто запустите эту команду в директории 
проекта и вы готовы использовать Git для управления своим проектом.

Обратите внимание на путь в ответ на команду git init: это ваша директория с проектом
и диркторией .git в ней. Директория .git является домашней для всех операций Git.

( Git Status )

Разумно использовать команду git status всё время, когда вы изучаете Git. Конечно это
будет удобно и когда вы будете опытнее. Вот как это работает. Предположим, у вас есть 
три файла в проекте:

-------------------------------------------------------------------------------------

Стр. 35

• README
• index.html
• default.css
Вы запустили git init в этой директории, затем запустили это:
\$ git status
# On branch master
#
# Initial commit
#
# Untracked files:
#
(use “git add <file>...” to include in what will be
committed)
#
#    READEME
#    default.css
#    index.html
nothing added to commit but untracked files present (use
“git add” to track)
Первая строка говорит вам, что вы в ветке master. Мы обсудим ветвление позже в этой
главе. Следующая строка - Initial commit - служит напоминанием того, что мы ещё 
ничего не закоммитили в наш новый Git репозиторий (мы подготавливаем 
инициализационный коммит). Дальше идёт список неверсируемых файлов. Вот что происходит:
Git по умолчанию не следит за всеми файлами в вашем репозитории с проектом. Вы должны 
указать что версировать. Мы будем смотреть на это в ближайшее время (статусное сообщение
даёт вам подсказку), но сейчас обратите внимание, что все три файла, которые мы имеем в
директории указаны как неверсируемые.

( Git Add )

Итак, Git увидел файлы в вашем проекте, но мы ещё не

--------------------------------------------------------------------------------------

Стр. 36

сказали Git версировать файлы, так давайте сделаем это сейчас. Мы сделаем это с помощью
команды git add.
Мы рассмотрим два способа это сделать. Первым, мы можем сказать Git версировать все 
файлы в директории (и все поддиректории), используя параметр . (точка):
\$ git add .
Если вы не хотите добавлять все файлы, вы можете назначить их индивидуально, передавая
их имена в качестве параметра.
\$ git add index.html default.css
Итак, что происходит, когда мы используем команду git add? Git "перемещает" файлы в то,
что называется промежуточная область. Вы ещё не сказали Git сделать снимок проекта. Это
подготовительный этап. Воспринимайте промежуточную область как погрузочный док: файлы уже
приготовлены, но ещё не погружены в грузовик. Это сделано для вас, чтобы вы смогли сказать
Git что необходимо сделать с файлами в промежуточной области. Предположим вы выполнили
вторую команду, поместив файлы index.html и default.css в промежуточную область. Что вы
получите в ответ на команду git status?
\$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#
(use “git rm --cached <file>...” to unstage)
#
#    new file: default.css
#    new file: index.html
#
# Untracked files:
#
(use “git add <file>...” to include in what will be

-------------------------------------------------------------------------------------

Стр. 37

committed)
#
#   
README
        Подсказка от Rock*
        Важно понять что Git не версирует файлы: он версирует содержимое. Это значит,
        что когда вы изменяете содержимое файла, добавляя или удаляя строки, вам 
        необходимо перезанести эти файлы в промежуточную область. Это может показаться
        неудобным, но это очень мощная концепция. Вы узнаете о шорткате для переноса в 
        промежуточную область и коммита редактируемых файлов в следующей главе.
Как вы можете видеть, Git добавил секцию к выводимой информации: "Изменения для 
фиксирования". Это значит, что файлы default.css и index.html находятся в погрузочном
доке, в ожидани дальнейших инструкций. Давайте дадим сейчас эту инструкция!

( Git Commit )

Как мы уже говорили, основным назначением систем управления исходным кодом является
хранение записи снимков вашего проекта так, чтобы она росла. Перед тем, как мы это 
сделаем, запустите run git ., чтобы убедиться, что всё находится в промежуточной 
области (загрузочном доке). Сейчас мы готовы сделать снимок.
Как мы уже говорили, корректным именем снимка проекта является коммит. Простейший
способ сделать коммит, это выполнить эту команду:
\$ git commit

-------------------------------------------------------------------------------------

Стр. 38

Это перенесёт вас с редактор командной строки по умолчанию. Вот что я получил:
{рисунок}
Каждый коммит, который вы делаете, вы снабжаете коротким сообщением, напоминающим
вам какие изменения в коммите. Это маленький список изменений, если хотите, учёт 
различий между этим и предыдущим коммитом. Так как это первый коммит в нашем проетке,
я просто введу "Initial commit" и закрою редактор. (Также есть много других строк - на
самом деле статусное сообщение Git - в редакторе только те строки, которые начинаются 
с символа # будут использоваться в сообщении коммита.)
Как только вы закроете редактор, вы получите следующий вывод:
[master (root-commit) 604ff85] initial commit
3 files changed, 10 insertions(+), 0 deletions(-)
create mode 100644 README
create mode 100644 default.css
create mode 100644 index.html

-------------------------------------------------------------------------------------

Стр. 39

Пока вы недолжны понимать всего этого, отметьте следующее:
        • Верхняя строка содержит три важные части: имя ветки в которой мы находимся
        (master, опять же, подробнее позже), SHA-1 хэш коммита (смотрите ниже) и наше
        сообщение коммита.
        • Следующая строка говорит вам что было сделано в этом коммите. Вы можете
        видеть, что 3 файла было изменено в этом коммите, 10 строк добавлено и ниодной
        не удалено.
        • И наконец мы видем, что Git создал наши 3 файла. Конечно их сделали мы, но Git
        создал запись о них в папке .git.
Давайте вернёмся к SHA-1 хэшу на минуту. SHA-1 -- это криптографическая хэш функция. В
кратце, Git берёт содержимое коммита и создаёт 40-ка символьный хэш из него. Без 
углубления в детали, я помечу, что вероятность созлать два идентичных хэша практически
невозможна. Это используется дл идентификации коммитов (и других вещей тоже) в Git. То,
что вы видите выше, это просто первая часть хэша. Обычно достаточно первых семи символов
для идентификации.
Вы можете увидеть больше информации о нашем коммите, запустив команду git log:
\$ git log
commit 80f84da53585307947546188cd0540a6ff63f64f
Author: Andrew Burgess <andrew8088@gmail.com>
Date:
Wed Jun 30 14:51:43 2010 -0400
initial commit
Сейчас вы можете видеть полный 40-ка символьный хэш. Вы также можете видеть автора (Git
использует те конфигурационные настройки), дату и время создания коммита, и сообщение
коммита. Как только вы сделаете больше коммитов, команда выведет эту информацию для всех
ваших коммитов, спускаясь от новых к старым. Название команды говорит само за себя. Это

-------------------------------------------------------------------------------------

Стр. 40

лог ваших коммитов. Мы будем более подробно изучать команду git commit. Мы вернёмся к
ней в 4 главе.

( Файлы игнорирования )

Давайте отвлечёмся от команд Git и взглянем на другую функцию: файл .gitignore. Как мы
увидели, Git автоматически обнаруживает другие файлы в нашей директории, но не 
добавляет их автоматически в промежуточную область или репозиторий. Давайте дбавим файл
"config.php" в наш проект. Предположим, что в нём некоторая приватная информация, скажем,
имя пользователя и пароль к нашему серверу и базе данных, которые мы не хотим 
обнародовать. Те, кто использует наш проект должны создать свой собственный файл 
config.php. Но если мы запустим git status, то мы получим это:
\$ git status
# On branch master
# Untracked files:
#
(use “git add <file>...” to include in what will be
committed)
#
#       
config.php
nothing added to commit but untracked files present (use
“git add” to track)
Это будет очень неудобно не забывать удаллять файл config.php всякий раз, когда мы 
подготавливаем коммит. Поэтому мы будем использовать ловкий трюк Git. В директории
вашего проекта создайте файл .gitignore. Затем просто поместите имя файла который
мы хотим игнорировать.
# file named .gitignore
       
config.php

-------------------------------------------------------------------------------------

Стр. 41

Это так просто. Сохраните и закройте файл. Теперь, если мы запустим git status:
\$ git status
# On branch master
# Untracked files:
#
(use “git add <file>...” to include in what will be
committed)
#
#       
.gitignore
nothing added to commit but untracked files present (use
“git add” to track)
Вы можете видеть, что Git обнаружил файл .gitignore. Я собираюсь добавить несколько
других строк в файл:
config.php
#Mac OS X files
.DS_Store
#Vim leave-behinds
*.swp
Обратите внимание на структуру: каждый пункт располагается на своей строке. Я могу
оставить комментарии, начав строку с #. Я могу указывать отдельные файлы или 
использовать маску, чтобы указывать группы файлов.
        Подсказка Rock*
        Если вы хотите исключить всё, кроме одного файла в определённом типе файлов,
        восклицательный знак (!) ваш помошник. Просто сделайте что-нибудь подобное в 
        вашем файле .gitignore:
        *.log
        !errors.log
        Старт строки с восклицательного знака говорит Git сключить всё, что находится 
        дальше. Поэтому, в этом случае, все лог-файлы, кроме error.log будут 
        проигнорированы.

-------------------------------------------------------------------------------------

Стр. 42

( Ветвление )

Одним из сильных свойств Git является способность к ветвлению. Что такое ветвление?
Представьте следующее: вы работаете над проектом и у вас есть идея новой фцнкции.
Вы не хотите рисковать испортить проект. Поэтому вы создаёте новую ветку в Git
репозитории для работы над функцией. Когда всё сделано и готово вы можете слить ваши
изменения в главную линию. Коротко, ветвление создаеёт безопасную песочницу (идентичную
главному проекту, когда начинаете) для ваших действий, где вам не приходится беспокоиться
о причинении вреда.
Поеп наш проект имеет только одну ветку, это ветка по умолчанию и обычно называется
master. Вы можете увидеть ветки, которые у вас есть, используя команду git branch.
\$ git branch
* master
Звёздочка предшествует названию ветки, в которой мы находимся. Итак, давайте создадим
другую ветку. Мы делаем это с помощью команды git branch:
\$ git branch authorization
Мы просто создали ветку с именем "authorization". Сейчас, если мы выполним команду 
git branch, мы увидим это.
\$ git branch
authorization
* master
Но мы до сих пор в ветке master. Итак, давайте переключимся в нашу новую ветку. Мы
можем сделать это с помощью git checkout:
\$ git checkout authorization
Switched to branch ‘authorization’

-------------------------------------------------------------------------------------

Стр. 43

Сейчас давайте создадим новый файл, скажем "oauth.php". Я помещу его в промежуточную
область и закоммичу.
\$ git status
# On branch authorization
# Untracked files:
#
(use “git add &lt;file>...” to include in what will be
committed)
#
#       
oauth.php
nothing added to commit but untracked files present (use
“git add” to track)
\$ git add oauth.php
\$ git commit
[authorization 8cdf227] added authentication
0 files changed, 0 insertions(+), 0 deletions(-)
create mode 100644 oauth.php
Теперь посмтрим на это: здесь доказательство того, что файл действительно сущетсвует:
{рисунок}

-------------------------------------------------------------------------------------

Стр. 44

Сейчас я переключусь обраnно в  ветку master:
\$ git checkout master
И сейчас взглянем на наш проект:
{рисунок}
Да, тот файл полностью исчез. Какие бы изменения вы не сделали в одной ветке, они не 
будут видны во всех других. Так как Git следит за содержимым, то это работает для
файлов и всех каталогов вплоть до строк и символов.
Существует несколько способов визуализировать ветвления. Чтобы нам что-то разглядеть,
я собираюсь сделать ещё два коммита, по одному в каждой ветке мы уже сделали.
Первый инструмент визуализации Git является GUI программа gitk, которую мы сейчас
рассмотрим. Для того, чтобы запустить её, просто выполлните команду:
\$gitk

-------------------------------------------------------------------------------------

Стр. 45

Это откроет другое окно, похожее на такое:
{рисунок}
В верхнем левом углу вы можете видеть историю с каждым коммитом, представленным точкой.
Также вы можете видеть сообщения коммитов. В вверху посередине вы можете видеть кто 
сделал каждый коммит, а справа дату и время. Сейчас это только мои коммиты, но если бы
это был реальный проект, то вы бы имели несколько людей, комитивших одновременно. Есть
несколько полей по середине. Двигаемся вниз, есть некоторые поля, котроые мы не будем
обсуждать. Справа внизу вы можете видеть более деталиованную информауию о выбранном
коммите вверху. Здесь указывается какой коммит следовал до (родительский коммит) и
какой коммит следует после (дочерний коммит). Справа вы можете видеть какие файлы
были подправлены или добавлены либо в форме "что нового" (patch view), либо "что здесь
нан момент коммита" (tree view).

-------------------------------------------------------------------------------------

Стр. 46

Но почему мы не видим нашу ветку "autorization"? Потому, что я выполнил команду gitk
из ветки master. Если мы переключимся в ветку "autorization" и повторим, то мы просто
получим эту ветку. Напротив, я выполню команду снова, но добавлю влаг --all.
        Подсказка Rock*
        Расширения команд наподобии --all для gitk называются флагами. Воспринимайте
        их как установки или опции для программ командой строки. В Mac однобуквенным
        флагам обычно предшествует тире (например ls -l), а словесным флагам обычно --
        двойное тире (например gitk --all). В Windows всем флагам предшествует слэш 
        (например dir /B). В большинстве случаев однобуквенные флаги являются
        аббревиатурами, которые помогают вам запомнить их. Например флаг в нижнем
        регистре l для команды ls означает "long form". Мы рассмотрим больше флагов
        Git в главе 4.
\$ gitk --all
Вот что это даст:
{рисунок}

-------------------------------------------------------------------------------------

Стр. 47

Сейчас вы можете видеть обе ветки сразу. ВЫ можетет видеть взаимоотношения между ними.
Здесь довольно ясно, что мы сделали один коммит в ветке master с момента разветвления
веткой autirization. Также ветка autorization имеет два коммита с момента создания.
Дугой способ увидеть дерево вашего Git репозитория, на этот раз не покадая командную
строку. Мы кратко использовали команду git log до этого. Давайте запустим её сейчас
чтобы увидеть что мы получим. Так же, как мы использовали флаг --all с gitk чтобы
увидеть все ветки, мы сделаем то же самое и с log:
\$ git log --all
commit 39a1b50c88f7bf2696b95b08ace27711b652a5c9
Author: Andrew Burgess &lt;andrew8088@gmail.com>
Date:
Thu Jul 1 15:55:22 2010 -0400
updated oauth lib
commit 22607bb6442324d4d97f2dda97832509be4f6773
Author: Andrew Burgess &lt;andrew8088@gmail.com>
Date:
Thu Jul 1 15:51:19 2010 -0400
added some JS functionality
commit 8cdf2272235a48996a37bdf1bb34ed5e2e8cf9d2
Author: Andrew Burgess &lt;andrew8088@gmail.com>
Date:
Thu Jul 1 07:18:02 2010 -0400
added authentication
commit af08f1bd72e9caec496da471694189eb33727a52
Author: Andrew Burgess &lt;andrew8088@gmail.com>
Date:
Thu Jul 1 07:15:21 2010 -0400
added .gitignore

-------------------------------------------------------------------------------------

Стр. 48

commit 80f84da53585307947546188cd0540a6ff63f64f
Author: Andrew Burgess &lt;andrew8088@gmail.com>
Date:
Wed Jun 30 14:51:43 2010 -0400
initial commit
Итак, мы получили информацию обо всех наших коммитах. Но где дерево? Попробуем так:
\$ git log --graph --all --oneline
* 39a1b50 updated oauth lib
* 8cdf227 added authentication
| * 22607bb added some JS functionality
|/
* af08f1b added .gitignore
* 80f84da initial commit
Я добавил туда два флага: флаг --graph который даёт нам дерево. Как вы можете видеть
это очень схоже с gitk. Как насчёт флага --oneline? Он просто уменьшает суммарную
информацию о каждом коммите который мы видим. Показывается первые семь символов хэша
и сообщение коммита. Вы не должны использовать --graph и --oneline вместе. Я так
сделал чтобы использовать меньше места.
Итак мы поговорили о ветвлении вашего кода для работы над отдельными идеями. Давайте
скажем сейчас что мы хотим объединить эти две ветки вместе. В Git это называется 
слиянием. Давайте посмотрим как это сделать.
Это самый простой способ. Заметьте: я в ветке master.
\$ git merge authorization
Merge made by recursive.
oauth.php |
7 +++++++
1 files changed, 7 insertions(+), 0 deletions(-)
create mode 100644 oauth.php

-------------------------------------------------------------------------------------

Стр. 49

Git выдаёт немонго информации о слиянии. Давайте посмотрим на наш лог коммитов снова:
\$git log --graph --all --oneline
*
08eaf7c Merge branch ‘authorization’
|\
| * 39a1b50 updated oauth lib
| * 8cdf227 added authentication
* | be96dbe editted index.html
* | 22607bb added some JS functionality
|/
* af08f1b added .gitignore
* 80f84da initial commit
Как вы можете видеть Git слил две ветки и закоммитил результат. Из сообщения коммита
видно что произошло: мы объединили ветку autorization. В большинстве случаев объединение
ваших веток будет так просто.

[ Метки ]

Иногда вы захотите сделать ссылку на некоторый коммит в истории вашего проекта.
Обычный пример это версии: метки это великолепный способ помечать различные версии, скажем,
библиотек и фреймворков. Вот как вы можете это сделать.
Как вы можете догадаться, команда, которую мы рассмотрим называется git tag. Существует
два типа меток: лёгкие и аннотированные. Лёгкие метки похожи на ветки, которые могут быть
обновлены. В днйствительности, они просто указатели. Аннотированные метки используются
более часто: они содержат больше информации,чем содержат обычные коммиты.
Когда вы находитесь в точке проекта, котрорую вы хотите пометить, вот что нужно делать.
Для лёгких ссылок это просто:
\$ git tag v0.5.6

-------------------------------------------------------------------------------------

Стр. 50

Заметьте, что имя метки является параметром. Тем не менее, часто разумнее, но не 
сложнее в использовании аннотированные метки:
\$ git tag -a stable-1
Если вы хотите добавить сообщение к метке, используйте флаг -m.
\$ git tag -a RC1 -m ‘the first release candidate’
Итак, теперь когда вы пометили свой прект, что могут сказать эти метки? Во-первых
запустите команду git tag безкаких-либо флагов и параметров, чтобы увидеть список ваших
меток. Вот вывод из маленького проекта:
\$ git tag
v0.5
Увидеть информацию о метке вы можете запустив команду git show и передав имя метки:
\$ git show v.0.5
tag v0.5
Tagger: Andrew Burgess <andrew8088@gmail.com>
Date:
Sat Jul 3 10:06:16 2010 -0400
half-way to release 1
commit 08eaf7c6b31157d0d5473b84abbbf265bc12cee5
Merge: be96dbe 39a1b50
Author: Andrew Burgess <andrew8088@gmail.com>
Date:
                
Sat Jul 3 07:28:16 2010 -0400
Merge branch ‘authorization’
Вы можете видеть кто сделал метку, когда она сделана и какое сообщение ей оставлено.
Вы также можете видеть на какой коммит она указывает.

-------------------------------------------------------------------------------------

Стр. 51

Я пошёл дальше и сделал ещё два коммита в этом проетке. Сейчас я запущу команду
git describe:
\$ git describe
v0.5-2-g8ee0f4a
Она сказала нам, что с метки "v0.5" мы сделали два коммита. Она также сообщает
нам хэш наиболее свежего коммита. Заметьте, что "-g" не является частью хэш коммита.
Этот суффикс означает "Git". В соответствии с документацией Git, это "применимо в 
окружении, где люди могут использовать различные системы управления исходным кодом".

[ Ссылки на коммиты: Git Treeish ]

Довольно часто вам нужно будет передавать ссылки на коммиты в качестве параметров
команд. Эти указатели на коммиты называются Treeish.
Вот несколько способов как это можно сделать:
        • SHA-1 хэш: использование хэша это самый надёжный способ указать на требуемый
        коммит. ВЫ не обязаны использовать все 40 символов. Обычно достаточно 5-7
        символов, чтобы различить их.
        • Ветки, метки или удалённые имена: использование имени ветки укажет на 
        последний коммит в этой ветке. Использование имени метки укажет на коммит,
        который ей помечен. Удалённость мы изучим в следующей главе, но вы тоже 
        можете её использовать.
        • HEAD: в Git HEAD это псевдоним последнего коммита текущеё извлечённой 
        ветки
        • Спецификатор даты: вы можете добавить спецификатор даты к концу имени ветки,
        чтобы получить коммит, который был на указанный момент времени. Например,
        чтобы посмотреть где была ветка feature 4 дня назад, вы должны сделать так:
        feature@{4 days ago}.

-------------------------------------------------------------------------------------

Стр. 52

        • Cпецификатор порядка: спецификатор порядка работает точно также, как и 
        спецификатор даты, за исключением, что он возвращает n-ый предыдущий коммит
        в ветке. Чтобы получить третий коммит с конца ветки feature, сделайте так:
        feature@{3}.
        • Carrot родитель: модифицирует указатель на коммит слияния в указатель на
        один из его родителей. Так, если HEAD это коммит слияния, HEAD^ будет указывать
        на тот родитель, который в этой же ветке. HEAD^2 будет указывать на коммит 
        другого родителя (коммит в другой ветке).
        • Tilde родитель: это работает так же как и carrot родители, за исключением
        что он указывает на прародитель коммита. Так, HEAD~ указывает на родитель
        коммита. HEAD~2 указывает на прародитель коммита.

[ Итог ]

Мы многое покрыли в этой главе: всё, начиная от установки Git на ваш компьютер до 
ветвления и слияния ваших проектов. Вы можете быть уставыми, но не сдавайтесь! В
следующей главе мы собираемся изучить более сложные команды Git, а также рассмотрим
более глубокий функционал команд, которые нам уже встречались.